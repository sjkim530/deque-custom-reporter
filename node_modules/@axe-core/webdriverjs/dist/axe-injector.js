"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var selenium_webdriver_1 = require("selenium-webdriver");
var axe_core_1 = require("axe-core");
var StaleElementReferenceError = selenium_webdriver_1.error.StaleElementReferenceError;
var AxeInjector = /** @class */ (function () {
    function AxeInjector(_a) {
        var driver = _a.driver, axeSource = _a.axeSource, builderOptions = _a.builderOptions, config = _a.config;
        this.driver = driver;
        this.axeSource = axeSource || axe_core_1.source;
        this.config = config ? JSON.stringify(config) : '';
        this.options = builderOptions || {};
        this.didLogError = false;
        this.options.noSandbox =
            typeof this.options.noSandbox === 'boolean'
                ? this.options.noSandbox
                : false;
        this.options.logIframeErrors =
            typeof this.options.logIframeErrors === 'boolean'
                ? this.options.logIframeErrors
                : false;
    }
    /**
     * Checks to make sure that the error thrown was not a stale iframe
     * @param {Error} error
     * @returns {void}
     */
    AxeInjector.prototype.errorHandler = function (err) {
        // We've already "warned" the user. No need to do it again (mostly for backwards compatibility)
        if (this.didLogError) {
            return;
        }
        this.didLogError = true;
        var msg;
        if (err instanceof StaleElementReferenceError) {
            msg =
                'Tried to inject into a removed iframe. This will not affect the analysis of the rest of the page but you might want to ensure the page has finished updating before starting the analysis.';
        }
        else {
            msg = 'Failed to inject axe-core into one of the iframes!';
        }
        if (this.options.logIframeErrors) {
            console.error(msg);
            return;
        }
        throw new Error(msg);
    };
    Object.defineProperty(AxeInjector.prototype, "script", {
        /**
         * Get axe-core source and configurations
         * @returns {String}
         */
        get: function () {
            return "\n    " + this.axeSource + "\n    " + (this.config ? "axe.configure(" + this.config + ")" : '') + "\n    axe.configure({ \n      allowedOrigins: ['<unsafe_all_origins>'], \n      branding: { application: 'webdriverjs' }\n    })\n    ";
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Removes the `sandbox` attribute from iFrames
     * @returns {Promise<void>}
     */
    AxeInjector.prototype.sandboxBuster = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                // outer promise needed because `executeAsyncScript`
                // does not return a "real promise" (ManagedPromise)
                // and we want to await it.
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        /* eslint-disable no-undef */
                        _this.driver
                            // https://github.com/vercel/pkg/issues/676
                            // we need to pass a string vs a function so we manually stringified the function
                            .executeAsyncScript("\n          var callback = arguments[arguments.length - 1];\n          var iframes = Array.from(\n            document.querySelectorAll('iframe[sandbox]')\n          );\n          var removeSandboxAttr = clone => attr => {\n            if (attr.name === 'sandbox') return;\n            clone.setAttribute(attr.name, attr.value);\n          };\n          var replaceSandboxedIframe = iframe => {\n            var clone = document.createElement('iframe');\n            var promise = new Promise(\n              iframeLoaded => (clone.onload = iframeLoaded)\n            );\n            Array.from(iframe.attributes).forEach(removeSandboxAttr(clone));\n            iframe.parentElement.replaceChild(clone, iframe);\n            return promise;\n          };\n          Promise.all(iframes.map(replaceSandboxedIframe)).then(callback);\n        ")
                            // resolve the outer promise
                            .then(function () { return resolve(); })
                            .catch(function (e) { return reject(e); });
                    })];
            });
        });
    };
    /**
     * Injects into the provided `frame` and its child `frames`
     * @param {WebElement[]} framePath
     * @returns {Promise<void>}
     */
    AxeInjector.prototype.handleFrame = function (framePath) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, framePath_1, frame, ifs, fs, frames, _a, frames_1, childFrames, error_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.driver.switchTo().defaultContent()];
                    case 1:
                        _b.sent();
                        _i = 0, framePath_1 = framePath;
                        _b.label = 2;
                    case 2:
                        if (!(_i < framePath_1.length)) return [3 /*break*/, 5];
                        frame = framePath_1[_i];
                        return [4 /*yield*/, this.driver.switchTo().frame(frame)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 2];
                    case 5:
                        if (!this.options.noSandbox) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.sandboxBuster()];
                    case 6:
                        _b.sent();
                        _b.label = 7;
                    case 7: return [4 /*yield*/, this.driver.executeScript(this.script)];
                    case 8:
                        _b.sent();
                        return [4 /*yield*/, this.driver.findElements({ tagName: 'iframe' })];
                    case 9:
                        ifs = _b.sent();
                        return [4 /*yield*/, this.driver.findElements({ tagName: 'frame' })];
                    case 10:
                        fs = _b.sent();
                        frames = ifs.concat(fs);
                        _a = 0, frames_1 = frames;
                        _b.label = 11;
                    case 11:
                        if (!(_a < frames_1.length)) return [3 /*break*/, 17];
                        childFrames = frames_1[_a];
                        framePath.push(childFrames);
                        _b.label = 12;
                    case 12:
                        _b.trys.push([12, 14, 15, 16]);
                        return [4 /*yield*/, this.handleFrame(framePath)];
                    case 13:
                        _b.sent();
                        return [3 /*break*/, 16];
                    case 14:
                        error_1 = _b.sent();
                        this.errorHandler(error_1);
                        return [3 /*break*/, 16];
                    case 15:
                        framePath.pop();
                        return [7 /*endfinally*/];
                    case 16:
                        _a++;
                        return [3 /*break*/, 11];
                    case 17: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Injects into all frames
     * @returns {Promise<void>}
     */
    AxeInjector.prototype.injectIntoAllFrames = function () {
        return __awaiter(this, void 0, void 0, function () {
            var ifs, fs, frames, _i, frames_2, childFrame, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // Ensure we're "starting" our loop at the top-most frame
                    return [4 /*yield*/, this.driver.switchTo().defaultContent()];
                    case 1:
                        // Ensure we're "starting" our loop at the top-most frame
                        _a.sent();
                        if (!this.options.noSandbox) return [3 /*break*/, 3];
                        // reinject any sandboxed iframes without the sandbox attribute so we can scan
                        return [4 /*yield*/, this.sandboxBuster()];
                    case 2:
                        // reinject any sandboxed iframes without the sandbox attribute so we can scan
                        _a.sent();
                        _a.label = 3;
                    case 3: 
                    // Inject the script into the top-level
                    // XXX: if this `executeScript` fails, we *want* to error, as we cannot run axe-core.
                    return [4 /*yield*/, this.driver.executeScript(this.script)];
                    case 4:
                        // Inject the script into the top-level
                        // XXX: if this `executeScript` fails, we *want* to error, as we cannot run axe-core.
                        _a.sent();
                        return [4 /*yield*/, this.driver.findElements({ tagName: 'iframe' })];
                    case 5:
                        ifs = _a.sent();
                        return [4 /*yield*/, this.driver.findElements({ tagName: 'frame' })];
                    case 6:
                        fs = _a.sent();
                        frames = ifs.concat(fs);
                        _i = 0, frames_2 = frames;
                        _a.label = 7;
                    case 7:
                        if (!(_i < frames_2.length)) return [3 /*break*/, 12];
                        childFrame = frames_2[_i];
                        _a.label = 8;
                    case 8:
                        _a.trys.push([8, 10, , 11]);
                        return [4 /*yield*/, this.handleFrame([childFrame])];
                    case 9:
                        _a.sent();
                        return [3 /*break*/, 11];
                    case 10:
                        err_1 = _a.sent();
                        this.errorHandler(err_1);
                        return [3 /*break*/, 11];
                    case 11:
                        _i++;
                        return [3 /*break*/, 7];
                    case 12: 
                    // Move back to the top-most frame
                    return [2 /*return*/, this.driver.switchTo().defaultContent()];
                }
            });
        });
    };
    /**
     * Inject axe and invoke provided callback when complete
     * @param {InjectCallback} callback
     * @returns {void}
     */
    AxeInjector.prototype.inject = function (callback) {
        var _this = this;
        this.injectIntoAllFrames()
            .then(function () { return callback(); })
            .catch(function (e) {
            if (_this.options.logIframeErrors) {
                return callback();
            }
            callback(e);
        });
    };
    return AxeInjector;
}());
exports.default = AxeInjector;
//# sourceMappingURL=axe-injector.js.map